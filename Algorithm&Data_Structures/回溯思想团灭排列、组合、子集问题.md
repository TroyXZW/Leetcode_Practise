# 78.子集

```
def backtrack(start, track):
    res.append(track[:])  # 一定要用列表的引用，否者后面更新track会改变res中元素的值, res.append(track)报错
    for i in range(start, len(nums)):
        track.append(nums[i])
        backtrack(i + 1, track)
        track.pop()


def subset():
    track = []
    backtrack(0, track)


if __name__ == "__main__":
    res = []
    nums = [1, 2, 3]
    subset()
    print(res)

"""
    关于引用
"""
# a = [1, 2]
# res = []
# res.append(a)
# print(res)
#
# a = [1, 2, 3]
# print(res)
#
# a.append(1)
# print(res)
```

# 46.全排列

```
def backtrack(nums, track):
    if len(nums) == len(track):
        res.append(track[:])  # 一定要用列表的引用，否者后面更新track会改变res中元素的值, res.append(track)报错
        return
    for i in range(len(nums)):
        if nums[i] in track:
            continue
        track.append(nums[i])
        backtrack(nums, track)
        track.pop()


def subset():
    if len(nums) == 0:
        return
    track = []
    backtrack(nums, track)


if __name__ == "__main__":
    res = []
    nums = [1, 2, 3]
    subset()
    print(res)
```

# 77.组合

```
def backtrack(start, track):
    if k == len(track):
        res.append(track[:])  # 一定要用列表的引用，否者后面更新track会改变res中元素的值, res.append(track)报错
        return
    for i in range(start, n + 1):
        track.append(i)
        backtrack(i + 1, track)
        track.pop()


def subset(n, k):
    if n <= 0 or k <= 0:
        return res
    track = []
    backtrack(1, track)


if __name__ == "__main__":
    res = []
    n, k = 4, 2
    subset(n, k)
    print(res)
```

# 37.解数独

```

```

# 37.括号生成

```

```
